# How Strings Are Stored in Java

## 1. String Storage Overview

In Java, **strings are objects**, not primitive types.
When you create a `String`, it gets stored in one of two memory areas:

| Type of Creation            | Memory Area Used                           |
| --------------------------- | ------------------------------------------ |
| Using literals (`"Hello"`)  | **String Constant Pool (SCP)** inside Heap |
| Using `new String("Hello")` | **Heap** (new object always)               |

---

## 2. What Is the String Constant Pool (SCP)?

The **String Constant Pool** is a special memory region inside the **Heap** managed by the JVM.

**Purpose**:

* Avoids creating multiple identical `String` objects.

* Improves memory efficiency and performance.

---

### Example 1 — String Literal

```java
String s1 = "Java";
String s2 = "Java";
```

Memory Behavior:

```
String Constant Pool:
+---------------------+
| "Java" (one object) |
+---------------------+

Heap:
s1 → "Java"
s2 → "Java"
```

✅ Both `s1` and `s2` point to the **same object** in SCP.
So:

```java
System.out.println(s1 == s2); // true
```

---

### Example 2 — Using `new` Keyword

```java
String s1 = new String("Java");
String s2 = new String("Java");
```

Memory Behavior:

```
String Constant Pool:
+---------------------+
| "Java"              |
+---------------------+

Heap:
s1 → new "Java"
s2 → new "Java"
```

❌ Both are **different objects** in the heap.
So:

```java
System.out.println(s1 == s2); // false
System.out.println(s1.equals(s2)); // true
```

---

## 3. The Role of the `intern()` Method

The **`intern()`** method ensures that a string is stored in the **SCP** and reuses it if already present.

### Example:

```java
String s1 = new String("Hello");
String s2 = s1.intern();
String s3 = "Hello";

System.out.println(s1 == s2); // false
System.out.println(s2 == s3); // true
```

### Explanation:

* `s1`: new object in heap.
* `s2`: references the interned `"Hello"` from SCP.
* `s3`: same literal `"Hello"` from SCP.
  Hence `s2` and `s3` are **identical references**.

---

## 4. Visual Memory Diagram

```text
+---------------------------------------------------+
|                     JVM HEAP                      |
|---------------------------------------------------|
|           String Constant Pool (SCP)              |
|      "Hello" <──┬── s3                            |
|                 │                                 |
|                 └── s2 (interned)                 |
|                                                   |
|   Normal Heap Area                                |
|      new String("Hello")  <── s1                  |
+---------------------------------------------------+
```

---

## 5. Behind the Scenes — `String` Internals

Internally, every `String` in Java holds:

```java
public final class String {
    private final byte[] value;  // stores characters
    private final byte coder;    // encoding (Latin-1 or UTF-16)
    private int hash;            // cached hashCode
}
```

### Key Points:

* **`value`** array stores the actual characters.

* **`final`** → cannot be reassigned, ensuring immutability.

* **`hash`** cached for fast lookups in hash-based collections (`HashMap`, `HashSet`).

---

## 6. Why String Pool Is Inside Heap (and not Permanent Generation)

In older Java (pre-Java 7):

* SCP was part of **PermGen (Permanent Generation)** — limited size → prone to `OutOfMemoryError`.

Since **Java 7 onwards:**

* SCP moved to **Heap**, allowing garbage collection of unused strings.

✅ Benefits:

* String Pool size grows dynamically with the heap.

* Unused interned strings can be GC’d (garbage collected).

---

## 7. Compiler Optimization — `+` Operator on Literals

The compiler optimizes string literals **at compile time**.

```java
String s1 = "Java" + "World";
String s2 = "JavaWorld";
System.out.println(s1 == s2); // true
```

✅ Both become `"JavaWorld"` at compile time → stored once in SCP.

But:

```java
String s3 = "Java";
String s4 = s3 + "World";
System.out.println(s4 == "JavaWorld"); // false
```

Because the concatenation uses a **runtime `StringBuilder`**, not compile-time optimization.

---

## 8. Garbage Collection and Strings

* **Literal strings** in SCP stay until JVM unloads the class or the string is no longer referenced (Java 7+).
* **Heap-created strings** (`new String()`) are GC-eligible like any other object.

Example:

```java
String s = new String("ABC");
s = null;  // eligible for GC (heap object only)
```

---

## 9. Common Interview Traps 

| Code Snippet                                      | Output           | Explanation                             |
| ------------------------------------------------- | ---------------- | --------------------------------------- |
| `String a = "abc"; String b = "abc";`             | `a == b → true`  | Same literal from SCP                   |
| `String a = new String("abc"); String b = "abc";` | `a == b → false` | One in Heap, one in SCP                 |
| `a.intern() == b`                                 | `true`           | `a.intern()` returns reference from SCP |
| `"ab" + "cd" == "abcd"`                           | `true`           | Compile-time optimization               |
| `"ab" + new String("cd") == "abcd"`               | `false`          | Runtime concatenation                   |

---

##  Key Takeaways

* **String literals** go to **SCP** — unique and shared.

* **`new String()`** always creates a **new Heap object**.

* **`intern()`** forces reference to SCP version.

* From **Java 7 onwards**, SCP is part of the **Heap** (GC-friendly).

* **String immutability** ensures SCP optimization, thread safety, and cached hashing.

---